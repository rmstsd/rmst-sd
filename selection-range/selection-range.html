<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title></title>
    <style type="text/css">
      .rich-text {
        background-color: #fff;
        border: 2px solid #c2c8ff;
        min-height: 200px;
        outline: none;
        padding: 5px;
      }

      .rich-text:focus {
        border-color: #266afc;
      }

      .user-tag {
        color: #fff;
        background-color: #ff8c53;
        padding: 0 5px;
        border-radius: 999em;
        margin: 0 4px;
      }

      .wrapper {
        padding-right: 100px;
        background-color: #009ad6;
      }

      .person-container {
        position: fixed;

        box-shadow: 0 0 10px #d8d8d8;

        background-color: #fff;
        border-radius: 5px;
        padding: 5px 0;
      }

      .person-item {
        padding: 7px;
        cursor: pointer;
      }

      .person-item:hover {
        background-color: #eee;
      }

      .file-img {
        width: 20px;
        height: 20px;
      }
    </style>
  </head>
  <body>
    <div class="rich-text" contenteditable="true" onblur="onblurr()">fdghdfjgfdf</div>

    <button onclick="focc()">获取焦点</button>

    <div class="person-container" style="display: none">
      <div class="person-item">李白</div>
      <div class="person-item">杜甫</div>
      <div class="person-item person-item1">上官婉儿</div>
    </div>

    <button onclick="insertImage()" onmousedown="return false">插入图片</button>
  </body>
  <script src="./caret-pos.js"></script>
  <script type="text/javascript">
    let lastEditRange
    function focc() {
      const { range } = getSelectionAndRange()
      document.querySelector('.rich-text').focus()

      var selection = getSelection()
      // 判断是否有最后光标对象存在
      if (lastEditRange) {
        // 存在最后光标对象，选定对象清除所有光标并添加最后光标还原之前的状态
        selection.removeAllRanges()
        selection.addRange(lastEditRange)
      }
    }

    function onblurr() {
      const { range } = getSelectionAndRange()
      lastEditRange = range
      console.log(1)
    }
    //

    function insertImage() {
      let img = document.createElement('img')
      img.src = '../image/avatar.jpeg'
      img.classList.add('file-img')

      const random = Math.floor(Math.random() * 100)
      console.log(random)
      img.setAttribute('file-id', random)

      const frag = document.createDocumentFragment()
      const nbsp = document.createElement('span')
      nbsp.innerHTML = '&nbsp;' // '&#8203;'
      frag.appendChild(img)
      frag.appendChild(nbsp)

      const { range, selection } = getSelectionAndRange()

      range.insertNode(img)
      selection.collapseToEnd()

      img.addEventListener('DOMNodeRemoved', () => {
        console.log('--', img)
        img = null
      })
    }

    const richTextDom = document.querySelector('.rich-text')
    const personDom = document.querySelector('.person-container')

    // 当观察到变动时执行的回调函数
    const callback = function (mutationsList, observer) {
      for (let mutation of mutationsList) {
        console.log(mutation.removedNodes[0])
      }
    }
    // 创建一个观察器实例并传入回调函数
    const observer = new MutationObserver(callback)
    // 以上述配置开始观察目标节点
    // observer.observe(richTextDom, { childList: true })

    personDom.onmousedown = evt => {
      evt.preventDefault()
    }
    personDom.onclick = evt => {
      const { innerText } = evt.target

      // document.execCommand('delete')
      document.execCommand('delete')

      addPerson(innerText)
    }

    richTextDom.oninput = evt => {}

    richTextDom.onmousedown = evt => {
      evt.stopPropagation()
    }

    richTextDom.onkeydown = evt => {
      ;['Enter', 'ArrowUp', 'ArrowDown'].includes(evt.key) && evt.preventDefault()
      if (evt.key === 'Backspace') {
        // evt.preventDefault()
        // console.log(evt)
        // const { selection, range } = getSelectionAndRange()
        // console.log(range.startContainer)
        // console.log(range.startContainer.previousElementSibling)
      }
    }
    richTextDom.onkeyup = evt => {
      if (evt.shiftKey && evt.key === '@') {
        const { left, top } = offset(richTextDom)
        personDom.style.left = `${left}px`
        personDom.style.top = `${top + 25}px`
        personDom.style.display = null
      }
    }

    richTextDom.onpaste = evt => {
      evt.preventDefault()
      const text = evt.clipboardData.getData('text')
      const textNode = document.createTextNode(text)
      const { range, selection } = getSelectionAndRange()
      range.insertNode(textNode)
      selection.collapseToEnd()
    }

    function getSelectionAndRange() {
      const selection = window.getSelection()
      const range = selection.getRangeAt(0) // 参数不能大于等于 `selection.rangeCount`
      return { selection, range }
    }

    function addPerson(name) {
      const spanWrapper = document.createElement('span')

      const spanUser = document.createElement('span')
      spanUser.setAttribute('contenteditable', false)
      spanUser.classList.add('user-tag')
      spanUser.innerText = '@' + name

      const zwnj_1 = document.createElement('span')
      zwnj_1.innerHTML = '&#8203'

      const zwnj_2 = document.createElement('span')
      zwnj_2.innerHTML = '&#8203'

      spanWrapper.append(zwnj_1, spanUser)

      const { range, selection } = getSelectionAndRange()

      range.insertNode(spanWrapper) //insertNode 插入后默认选中这个 `选区`
      selection.collapseToEnd() //collapse(zwnj, 1)
      // selection.collapse(zwnj, 1)

      personDom.style.display = 'none'
    }

    /*
		---取决鼠标移动的方向
		锚点: anchor --锚指的是一个选区的起始点（不同于HTML中的锚点链接，译者注）。当我们使用鼠标框选一个区域的时候，锚点就是我们鼠标按下瞬间的那个点。在用户拖动鼠标时，锚点是不会变的。

		焦点: focus --选区的焦点是该选区的终点，当您用鼠标框选一个选区的时候，焦点是你的鼠标松开瞬间所记录的那个点。随着用户拖动鼠标，焦点的位置会随着改变。

		范围: range
		范围指的是文档中连续的一部分。一个范围包括整个节点，也可以包含节点的一部分，例如文本节点的一部分。用户通常下只能选择一个范围，但是有的时候用户也有可能选择多个范围（例如当用户按下Control按键并框选多个区域时，Chrome中禁止了这个操作，译者注）。“范围”会被作为 Range 对象返回。Range对象也能通过DOM创建、增加、删减
		
		selection.toString() 得到选择的文本, 文本, 文本
		*/

    //
  </script>
</html>

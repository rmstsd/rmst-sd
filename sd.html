<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PixiJS gl.POINTS Demo</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #111;
      }
      canvas {
        display: block;
      }
      #ui {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: sans-serif;
        background: rgba(0, 0, 0, 0.5);
        padding: 10px;
        border-radius: 4px;
        pointer-events: none;
      }
    </style>
    <!-- 引入 PixiJS v7 (稳定支持 WebGL1/2 及本案例 API) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
  </head>
  <body>
    <div id="ui">
      <div>数量: 10,000 个圆</div>
      <div>操作: 鼠标滚轮缩放，左键拖拽平移</div>
      <div>效果: 圆的位置随坐标系缩放，但像素大小(10px)保持不变</div>
    </div>

    <script>
      // 1. 初始化 Pixi 应用
      const app = new PIXI.Application({
        resizeTo: window,
        backgroundColor: 0x1099bb,
        antialias: true,
        autoDensity: true,
        resolution: window.devicePixelRatio || 1
      })
      document.body.appendChild(app.view)

      // 2. 准备数据：1万个点
      const count = 100000
      const buffer = new Float32Array(count * 2)

      // 随机分布在一个 2000x2000 的世界范围内
      for (let i = 0; i < count; i++) {
        buffer[i * 2] = Math.random() * 2000 - 1000 // x
        buffer[i * 2 + 1] = Math.random() * 2000 - 1000 // y
      }

      // 3. 创建 Geometry
      const geometry = new PIXI.Geometry().addAttribute('aVertexPosition', buffer, 2)

      // 4. 编写 Shader (利用 gl.POINTS)

      // Vertex Shader: 处理位置和点大小
      const vertexSrc = `
            precision mediump float;
            attribute vec2 aVertexPosition;
            
            // Pixi 内置矩阵
            uniform mat3 translationMatrix;
            uniform mat3 projectionMatrix;
            
            // 自定义参数
            uniform float uPointSize;

            void main() {
                // 标准变换：将世界坐标 -> 屏幕坐标
                // 这一步保证了点会随着舞台缩放而改变位置
                gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
                
                // 【核心】固定点的大小，不乘以缩放系数
                gl_PointSize = uPointSize;
            }
        `

      // Fragment Shader: 将方点画成圆
      const fragmentSrc = `
            precision mediump float;
            uniform vec4 uColor;

            void main() {
                // 计算当前像素距离点中心的距离 (gl_PointCoord 范围是 0.0~1.0)
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);

                // 简单的 SDF 绘制圆形
                // 如果半径 > 0.5 则丢弃 (形成硬边缘)
                if (dist > 0.5) discard;

                // 可选：加一点抗锯齿 (边缘虚化)
                // float alpha = 1.0 - smoothstep(0.45, 0.5, dist);
                // gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);
                
                gl_FragColor = uColor;
            }
        `

      // 5. 创建 Shader 和 Mesh
      const shader = PIXI.Shader.from(vertexSrc, fragmentSrc, {
        uPointSize: 10.0 * (window.devicePixelRatio || 1), // 物理像素大小，适配高清屏
        uColor: [1.0, 1.0, 0.0, 1.0] // 黄色 rgba
      })

      const pointsMesh = new PIXI.Mesh(geometry, shader)

      // 关键：设置为点绘制模式
      pointsMesh.drawMode = PIXI.DRAW_MODES.POINTS

      // 将 Mesh 放入一个容器，方便我们操作容器的缩放/位移
      const worldContainer = new PIXI.Container()
      worldContainer.addChild(pointsMesh)

      // 初始居中
      worldContainer.position.set(app.screen.width / 2, app.screen.height / 2)

      app.stage.addChild(worldContainer)

      // ----------------------------------------------------
      // 交互逻辑：缩放和平移
      // ----------------------------------------------------

      // 滚轮缩放
      app.view.addEventListener('wheel', e => {
        e.preventDefault()
        const scaleFactor = 1.1
        const direction = e.deltaY > 0 ? 1 / scaleFactor : scaleFactor

        // 简单的缩放逻辑（以中心为锚点简化演示）
        // 实际项目中通常需要以鼠标位置为锚点缩放
        worldContainer.scale.x *= direction
        worldContainer.scale.y *= direction
      })

      // 鼠标拖拽平移
      let isDragging = false
      let lastPos = null

      app.stage.eventMode = 'static'
      app.stage.hitArea = app.screen

      app.stage.on('pointerdown', e => {
        isDragging = true
        lastPos = e.global.clone()
      })

      app.stage.on('pointerup', () => {
        isDragging = false
      })
      app.stage.on('pointerupoutside', () => {
        isDragging = false
      })

      app.stage.on('pointermove', e => {
        if (!isDragging) return
        const newPos = e.global
        worldContainer.x += newPos.x - lastPos.x
        worldContainer.y += newPos.y - lastPos.y
        lastPos = newPos.clone()
      })
    </script>
  </body>
</html>

<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
		<title>梦幻独角兽</title>
		<style type="text/css">
		body {
			margin: 0;
		}

		button {
			cursor: pointer;
		}
		</style>
	</head>
	<body>
		<button id="btn">触发吗</button>

		<div class="container"></div>
	</body>
	<script type="text/javascript">
	window.onload = () => {

		/*
			dom事件也遵循`事件循环`的规则
				- 但是, 用js触发 和 鼠标点击是不一样的
		*/
		// btn.onclick = function() {
		// 	console.log('click')
		// }

		// btn.click()
		// let d = Date.now()
		// while (d + 1000 > Date.now()) {}		// 同步代码未执行完毕的时候不会执行事件处理程序
		// console.log(6)

		// return

		/*
			同步和异步的区别
			
			手写用 promise 加载一张图片
			
			前端异步场景
		*/

		/*
			单线程: 只能同时做一件事 	-异步是因为js是单线程而衍生出来的, 不是为了异步而异步
			浏览器和node.js支持js启动进程
			js 和 dom 渲染共用一个进程, 因为js可能修改dom结构 -js执行的时候dom渲染必须停止, dom渲染的时候js执行也必须停止
		*/

		function api(xx) {
			return new Promise((resolve, reject) => {
				setTimeout(() => {
					xx > 10 ? resolve(xx) : reject(xx)
				}, 1000)
			})
		}

		// api(8).then(res => {
		// 	console.log(res)
		// 	return api(12)
		// }).then(res => {
		// 	console.log(res)
		// 	return api(13)
		// }).then(res => {
		// 	console.log(res)
		// }).catch(err => {
		// 	console.purple(err)
		// })


		/*
			1. 描述事件循环的机制		dom事件, ajax, setTimeout 都是基于 event loop
				js 是单线程运行, 异步要基于回调来实现, 事件循环就是异步回调的实现原理
				
				- 如果某一行执行报错, 则停止下面代码的执行; 先执行同步代码, 在执行异步代码
				
				- 执行栈( Call Stack )为空, 即同步代码执行完的时候, 进行微任务, 尝试进行DOM渲染, 之后 event loop 开始工作
				- event loop 会轮询查找 Callback Queue, 如果有则移动到 Call Stack 执行, 持续轮询查找
				
				( setTimeout 在 指定时间后, 将回调函数放入 Callback Queue )
				
			
			2. 宏任务与微任务的区别
			
			3. Promise 有哪三种状态, 如何变化
			
				then 和 catch 对于状态的改变
				
				- then 正常返回 resolved, 里面有报错则返回 rejected
				- catch 正常返回 resolved, 里面有报错则返回 rejected
		*/


		const p1 = Promise.resolve().then(() => {
			// throw new Error('哈哈哈')
		})
		console.log(p1)

		// Promise.resolve().then(() => {
		// 		console.log(1)
		// 		throw new Error('哈哈哈')
		// 	}).then(() => {
		// 		console.log(2)
		// 	}).then(() => {
		// 		console.log(3)
		// 	}).catch(err => {
		// 		console.error(err)
		// 	}).then(() => {
		// 		console.log(6)
		// 	})


		// (async function () {

		// 	console.log('s')
		// 	const a = await 100
		// 	console.log('a', a)

		// 	const b = await Promise.resolve(200)
		// 	console.log('b', b)

		// 	const c = await Promise.reject(300)
		// 	console.log('c', c)

		// 	console.log('end')

		// })()


		/*
		try ...catch 捕获 Promise 异常
		*/
		// !(async function() {

		// 	const p4 = Promise.reject('errsh')

		// 	try {
		// 		const r = await p4
		// 		console.log(r)
		// 	} catch (e) {
		// 		//TODO handle the exception
		// 		console.log('err -> ', e)
		// 	}

		// })()

		// 执行顺序
		function execOrder() {
			async function as1() {
				console.log('as1 s')
				await as2()
				console.log('as1 e')
			}
			async function as2() {
				console.log('as2')
			}
			console.log('s s')
			as1()
			console.log('s e')
			// s s -> as1 s -> as2 -> s e -> as1 e
		}
		// execOrder()

		// ---------------------------------------

		function muti(num) {
			return new Promise((resolve, reject) => {
				setTimeout(() => {
					resolve(num * num)
				}, 1000)
			})
		}

		const nums = [1, 2, 3]
		// nums.forEach(async item => {
		// 	const res = await muti(item)
		// 	console.log(res)
		// })

		// ;
		// (async () => {
		// 	for (let s of nums) {
		// 		const res = await muti(s)
		// 		console.log(res)
		// 	}
		// })()


		// ----------------------------------------------------

		/*
			macroTask 宏任务			microTask 微任务
			
			- 什么是宏任务，什么是微任务
			- event loop 和 DOM渲染
			- 宏任务和微任务的区别
		*/
		/*
			宏任务: setTimeout, setInterval, Ajax, DOM事件 	-- 在DOM渲染后触发
			微任务: Promise async/await			-- 在DOM渲染前触发
			微任务执行比宏任务早
		*/

		// 测试dom渲染与js执行
		function createEle(text) {
			const h1 = document.createElement('h1')
			h1.innerText = text
			return h1
		}

		const container = document.querySelector('.container')
		container.appendChild(createEle(1))
		container.appendChild(createEle(2))
		container.appendChild(createEle(3))

		console.log('append')


		Promise.resolve().then(() => {
			console.log('微 ', container.children.length)
			// alert('微任务') 	// DOM 没渲染
		})

		setTimeout(() => {
			console.log('宏 ', container.children.length)
			// alert('宏任务')	// DOM 已渲染
		})
		waitSync()

		// alert('阻断js执行, 阻断DOM渲染')

		// 同步等待指定秒数
		function waitSync(t = 2000) {
			let d = Date.now()
			while (d + t > Date.now()) {}
			console.log('同步的等待')
		}



	}
	</script>
</html>

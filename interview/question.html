<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body></body>

  <script>
    /*
      # 如何捕获 `js` 中的异常
    */
    try {
    } catch (err) {}
    window.error = function (msg, source, lineNum, colNum, error) {
      /*
        - 对于跨域的js, 如`CDN`的, 不会有详细的报错信息
        - 对于压缩的 js, 要配合 `sourceMap` 反查到未压缩的代码的行和列
      */
    }

    const p = new URLSearchParams(location.search)
    console.log(p)
    const map = Array.from(p.entries())

    console.log(map)
    // const oo = map.reduce((acc, [k, v]) => {
    //     acc[k] = v
    //     return acc
    // }, {})
    // console.log(oo)

    // console.log(Object.fromEntries(map))

    // # isEqual
    const a1 = {
      b: 1,
      c: { d: 2 }
    }
    const a2 = {
      b: 1,
      c: { d: 2 }
    }

    function isObject(obj) {
      return typeof obj === 'object' && obj !== null
    }
    // 全等 -- 递归函数
    function isEqual(o1, o2) {
      // 只要有一个是原始数据类型 直接用 === 比较  // 不考虑函数
      if (!isObject(o1) || !isObject(o1)) {
        return o1 === o2
      }

      // 传入的两个是一样的对象 -传入两个`o1`的情况
      if (o1 === o2) return true

      // 两个都是引用数据类型, 而且不相等
      // 1. 先比较 keys 的数量
      const o1ks = Object.keys(o1)
      const o2ks = Object.keys(o2)
      if (o1.length !== o2.length) return false

      // 以 o1 为基准, 和 o2 进行递归比较
      for (let key in o1) {
        const res = isEqual(o1[key], o2[key])
        if (res === false) return false
      }

      return true
    }

    console.log(isEqual(a1, a2))

    //
  </script>
</html>
